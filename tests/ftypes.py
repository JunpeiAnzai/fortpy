"""Unit testing module for the ftypes functionality included in the fortpy 
interoperability package.
"""
import unittest as ut
import sys
from os import path, mkdir
sys.path.append(path.abspath(".."))

import fortpy
from fortpy.code import CodeParser
from fortpy import settings
from fortpy import msg
from fortpy.interop import ftypes as f90

from numpy import array, allclose

class TestFtypes(ut.TestCase):
    """Runs ftypes unit tests for generating wrapper modules in fortran
    and python and then compiling and running certain of the subroutines
    via the python interface.
    """
    @classmethod
    def setUpClass(cls):
        """Checks that the fortran modules being ftyped are present in
        the test folder; initializes the objects for writing and compiling
        the wrappers and python modules.
        """
        #First get the source directory setup correctly. For these tests
        #we are going to use the config libraries instead of duplicating
        #the code. Only the one module being wrapped will get copied.
        cls.fdir = path.join(path.abspath("."), "ftypes")
        cls.source = path.join(cls.fdir, "symmetry_module.f90")
        cls._check_dir()
        
        settings.use_filesystem_cache = False
        cls.parser = CodeParser()
        cls.parser.parse(cls.source)

        cls.dependencies = ["{}_c".format(m) for m in cls.parser.modules]
        cls.originals = list(cls.parser.modules.keys())
        cls.writers = {}

        #Setup the default test data the we use to run the python wrapper module
        #methods after ftypes is done.
        cls.lattice = array([[.5,.5,0],[0,.5,.5],[.5,0,.5]])
        cls.atomtypes = array([1])
        cls.basis = array([[0],[0],[0]])

    @classmethod
    def _check_dir(cls):
        """Makes sure the fortran module being wrapped is present in the
        ftypes folder for unit testing.
        """
        if not path.isdir(cls.fdir):
            mkdir(cls.fdir)
        if not path.isfile(cls.source):
            raise ValueError("The symmetry_module.f90 file required to unit test "
                             "the ftypes module is missing in {}".format(cls.fdir))

    def test_0_writef90(self):
        """Tests the writing of the wrapper F90 module as well as the compilation
        of the *.a library for the dependency modules required by symmetry_module.f90
        """
        for modname, module in self.parser.modules.items():
            msg.info("Writing wrapper module for {}".format(modname))
            fwriter = f90.WrapperModule(module, "celib", self.fdir,
                                        link="/Users/trunks/codes/celib/trunk/celib.a")
            self.writers[modname] = fwriter
            fwriter.write_f90()
            msg.okay("Finished writing {}_c.f90".format(modname))

    def test_1_make(self):
        """Tests compilation of the wrapper module into a shared library that can
        be used by ctypes.
        """
        #We can compile all these modules together into a single shared library.
        writer = self.writers.values()[0]
        self.code = writer.make(remake=True, dependencies=self.dependencies)
        self.assertEqual(self.code, 0)

    def test_2_writepy(self):
        """Tests the writing of the python module that interacts with the fortran
        shared library via ctypes.
        """
        for modname in self.originals:
            msg.info("Writing python wrapper module {}.py".format(modname))
            self.writers[modname].write_py()
            msg.okay("Finished writing {}.py".format(modname))

    def test_3_primitive(self):
        """Tests the make_primitive subroutine from the symmetry module via the python
        wrapper module that was generated by ftypes.
        """
        #We need to change the python path now to include the ftypes directory
        #that has the wrapper modules.
        sys.path.insert(0, self.fdir)
        from celib.symmetry_module import make_primitive
        result = make_primitive(self.lattice, self.atomtypes, self.basis, True, 1e-10)
        #In this case, we are already using the primitve FCC cell, so the matrices etc.
        #should return *unchanged* from the routine.
        self.assertTrue(allclose(result.avecs, self.lattice))
        self.assertTrue(allclose(result.atomtype, self.atomtypes))
        self.assertTrue(allclose(result.atom_pos, self.basis))

    def test_4_sgops(self):
        """Tests the space group finder that returns all the rotation matrices for a
        lattice.
        """
        from celib.symmetry_module import get_spacegroup
        result = get_spacegroup(self.lattice, self.atomtypes, self.basis, True, 1e-10)
        #The FCC lattice has 48 point group operations; we want to check each of them
        #against the correct values.
        self.assertEqual(result.sg_op.shape, (3,3,48))
        #We have to load the correct symmetry operations from file to check against.
        sgops = path.join(self.fdir, "sgops.dat")
        with open(sgops) as f:
            lines = f.readlines()
        model = self._read_sgopgs(lines, 48)

        for i in range(48):
            self.assertTrue(allclose(model[i], result.sg_op[:,:,i]),
                            "\n{}\n{}\n\n{}".format(i, model[i], result.sg_op[:,:,i]))
            
    def _read_sgopgs(self, lines, n):
        """Reads in the model matrices from the specified list of lines from the
        model output file.
        """
        model = []
        for i in range(1, n*4, 4):
            matrix = []
            for j in range(3):
                rows = map(float, lines[j+i].split())
                matrix.append(rows)
            model.append(array(matrix))

        return model
